#summary The internal structure of Mobility-RPC protocol messages
#labels Featured

The internal structure of Mobility-RPC protocol messages. See MobilityRpcProtocol for an overview of the protocol.

<wiki:toc max_depth="3" />

=Mobility-RPC Protocol Message Definitions=

Mobility-RPC uses [http://code.google.com/apis/protocolbuffers/ Google Protocol Buffers] (protobuf) to encode messages for sending "on the wire".

Protocol messages are defined using protobuf syntax, each message defined in a .proto file in the `src/main/proto` directory.

Google Protocol Buffers provides a `protoc` compiler, which generates Java class files from these .proto files. These classes allow the library to assemble protocol messages, and convert them to and from binary efficiently for sending over the network.

==Shared Components==

First, some _shared components_ of protocol messages, which are reused in several other messages.

===UUID Component===

`component_uuid.proto`
{{{
package com.googlecode.mobilityrpc.protocol.protobuf;

// A 128-bit id, transferred as two 64-bit longs
message UUID {
    required sint64 least_significant_bits = 1;
    required sint64 most_significant_bits = 2;
}
}}}
This defines a signed 128-bit number, which is transmitted as two signed 64-bit integers comprising the least significant and most significant 64 bits respectively. In Java, the [http://docs.oracle.com/javase/6/docs/api/java/util/UUID.html java.util.UUID] class constructor accepts these least significant and most significant bits, allowing the Java representation to be reconstructed.

===!SerializationFormat Component===

`component_serialization_format.proto`
{{{
package com.googlecode.mobilityrpc.protocol.protobuf;

enum SerializationFormat {
    JAVA = 0;
    KRYO = 1;
    JBOSS_MARSHALLING = 2;
}
}}}
Whenever a serialized object is transmitted, the `SerializationFormat` is included in the same message. This indicates to the receiving side which deserializer it should use to decode the message. Mobility-RPC currently only supports the Kryo format, and the additional formats listed here are remnants from earlier experimental implementations, provided for reference. This mechanism allows backward compatibility with previous formats, support for adding a new serialization format if desired, or the use of different serializers in different scenarios.

===!RequestIdentifier Component===

`component_request_identifier.proto`
{{{
package com.googlecode.mobilityrpc.protocol.protobuf;
import "component_uuid.proto";

message RequestIdentifier {
    // A UUID which identifies the relevant class loader to use on remote machines
    // for deserializing objects and caching classes
    // This is usually generated as a UUID on the first/initiating client,
    // but could be persistent/constant for some applications
    required UUID session_id = 1;

    // A UUID generated by the client for each request it sends, which will allows it
    // to identify the relevant request object when the UUID is echoed back to the client
    // by a remote machine in an execution response message on completion of the request
    required UUID request_id = 2;

    // An optional arbitrary string generated by the client which describes the execution request,
    // for debugging purposes on both client and remote machine
    optional string request_label = 3 [default = "<no label>"];
}
}}}
The `RequestIdentifier` component encapsulates:
 * A session id (128-bit UUID) which identifies the session to which a message is addressed on a remote machine. For example an execution request message will be generated by a session on the client machine, and in doing so the session will encapsulate its own session id in the request message it sends to a remote machine
 * A request id (128-bit UUID) which is generated by the client. This request id is copied by the server into any messages it sends back to the client in response to the original request. If a thread in the client is blocked waiting for a response, this technique allows the library in the client to look up the library-managed object containing the method on which the thread is blocked and unblock the thread supplying it the response
 * A request label (optional) which is an arbitrary string generated by the client which describes the execution request, and which both client and server will print if debug logging is enabled

==Protocol Messages==

The following are the formats of the actual protocol messages, which reuse some of the components above.

===!ResourceRequest Message===

`message_resource_request.proto`
{{{
package com.googlecode.mobilityrpc.protocol.protobuf;
import "component_request_identifier.proto";

message ResourceRequest {
    // The name of the class or resource required from the class loader on the remote machine.
    // This name will be supplied to sessionClassLoader.getResourceAsStream(String name) on the remote machine.
    // In the case of requesting bytecode for a class, this name should be the binary name of the class
    // with '/'-separated path name and '.class' appended. E.g. class com.foo.Bar -> com/foo/Bar.class
    repeated string resource_name = 1;

    // Request identifier which will be echoed back to the client by the server, identifies the session and
    // request on the client to which the response will be addressed
    required RequestIdentifier request_identifier = 2;
}
}}}

The `ResourceRequest` message is sent by a remote machine to a local machine, when it requires the local machine to upload a class definition or some resource file from the classpath.

Typically this will be sent when a mobile object is transferred to a remote machine _for the first time_, and so the remote machine needs the class definitions from the local machine so it can deserialize the object. Subsequently the remote machine will cache classes and resources in the class loader for the session on the remote machine. Objects of the same type sent subsequently would be deserialized from cached classes. Also it should be noted that classes which are already deployed to the remote machine, will never be requested.

The `ResourceRequest` message encapsulates:
 * A `RequestIdentifier`, which the server will copy into its response to this request, to allow the library to unblock the thread waiting for requested classes to arrive
 * A _repeated_ resource (e.g. class) name. In protobuf syntax, this means a _collection_ of resource names
   * Note that this allows a machine to request multiple classes in a single round trip
   * Mobility-RPC can require multiple classes to deserialize an object it has not seen before
   * Although not currently implemented, the library might be enhanced to avail of this "hook" in future, supporting requests for multiple classes in a single operation. This would have the potential to greatly reduce the number of round trips between server and client when an object is first deserialized at the server
   * Since the library controls deserialization, it would be possible to extract a list of the classes required to deserialize an object from serialized data. These classes could then be pre-loaded from the client in a single round trip
   * Alternatively, it would be possible for the client-side serializer to notify the server of required classes, see the `ResourceResponse` message below
 * In the current implementation, the server will request one class at a time

===!ResourceResponse Message===

`message_resource_response.proto`
{{{
package com.googlecode.mobilityrpc.protocol.protobuf;
import "component_request_identifier.proto";

message ResourceData {
    // The name of the class or resource requested, as provided by the SessionClassLoader on the local machine
    required string resource_name = 1;
    // The bytecode of the class or binary data of the resource requested
    required bytes resource_data = 2;
}
message ResourceResponse {
    // The requested bytecode or binary resource data
    repeated ResourceData resource_data = 1;

    // The request identifier, copied from the corresponding resource request originally sent by the client
    required RequestIdentifier request_identifier = 4;
}
}}}

The `ResourceResponse` message encapsulates:
 * A `RequestIdentifier` which is copied from the `ResourceRequest` message that originated the request
 * Repeated (a collection of) `ResourceData` components, which are comprised of resource name-byte array pairs
   * Note that this allows the client to return multiple classes to the server in a single round trip
   * Although not currently implemented, as a possible future enhancement, the protocol has been designed to allow the client to return more classes to the server than the server requested
   * Since the library controls serialization, it would be possible for the client to compose a list of classes which would be required to deserialize any particular object
   * This would allow the client to use knowledge of which dependent classes the server might require to deserialize an object based on a particular class, especially on the first occasion that the client sees a request for a particular class from a particular server
   * This would be an alternative mechanism to reduce round trips from server to client
 * In the current implementation, the client will return only the classes explicitly requested by the server

===Ping Message===

`message_ping.proto`
{{{
package com.googlecode.mobilityrpc.protocol.protobuf;
import "component_uuid.proto";

// A message which can be sent at any time by the client
// to validate that a connection is still up
message Ping {
    // A UUID generated by the client when it generates a Ping request,
    // which will be echoed back in a Pong response
    required UUID request_id = 1;

    // An arbitrary string which can be sent for debugging purposes
    required string message = 2;
}
}}}

The Ping message allows the library to test that the underlying transport is working. If the library receives a Ping message, it will simply echo it back in a Pong message via the same connection. Note that the library does not automatically send Ping requests, this is mostly for live testing from a manually controlled client.

The Ping message encapsulates:
 * A request id (128-bit UUID) which is generated by the client and copied by the server into a Pong message which it immediately sends back to the client
 * A string message, which can be printed to client and server logs when debug logging is enabled

===Pong Message===

`message_pong.proto`
{{{
package com.googlecode.mobilityrpc.protocol.protobuf;
import "component_uuid.proto";

// A message sent by the machine at the remote side of a connection
// in response to a Ping message
message Pong {
    // The request_id sent by the client when it sent the Ping request
    // to which this Pong message is the reply
    required UUID request_id = 1;

    // An arbitrary string which can be sent for debugging purposes
    required string message = 2;
}
}}}

The Pong message encapsulates:
 * A request id (128-bit UUID) which is supplied by the client in a Ping message and copied by the server into the Pong reply message
 * A string message, supplied by the client, which may be appended to by the server, which can be printed to client and server logs when debug logging is enabled

===!ExecutionRequest Message===

`message_execution_request.proto`
{{{
package com.googlecode.mobilityrpc.protocol.protobuf;
import "component_serialization_format.proto";
import "component_request_identifier.proto";

message ExecutionRequest {
    enum ExecutionMode {
        RETURN_RESPONSE = 0;
        FIRE_AND_FORGET = 1;
    }

    // A serialized Runnable or Callable object
    required bytes serialized_executable_object = 1;

    // The serialized format of the executable object e.g. whether Kryo or Java serialization was used
    required SerializationFormat serialization_format = 2;

    // Whether the remote host needs to return a response to the client when the execution completes
    required ExecutionMode execution_mode = 3 [default = RETURN_RESPONSE];

    // Request identifier, indicates relevant session and identifies the relevant request to the client when
    // response messages are returned
    required RequestIdentifier request_identifier = 4;
}
}}}

The `ExecutionRequest` message allows the local application to send an object (or graph of objects) to a remote application, and request that the library in the remote application invoke the object in a certain way.

The `ExecutionRequest` message is comprised of:
 * A serialized object or object graph, where the root of the graph is an object which implements interface `java.lang.Runnable` or `java.util.concurrent.Callable`
   * Note that the root of this graph defines the entry point for the sever to invoke the object
   * Typically the root of this graph will be an anonymous class or closure, calling some other method in its enclosing object or some referenced object
   * Hidden references are stored in _synthetic fields_ within inner and anonymous classes. These references point to the enclosing object of the inner class. By exploiting these references it is possible to serialize an entry point and its related objects, without requiring the related objects to implement interfaces
 * A field which indicates the serialization format of the serialized object
 * An `ExecutionMode` field, having one of two possible values:
   * `RETURN_RESPONSE` indicates that the client will block for a response from the server which contains:
     * An indication of whether or not the server invoked the entry point (method) successfully
     * The object returned by the entry point/method
     * An exception, in the case that the entry point/method threw an exception
       * The library will re-throw this exception to the calling thread in the client
   * `FIRE_AND_FORGET` indicates that the client will not block for a response from the server and that the server should not return any response at all
     * This can be considered an indication from the client that the server should make a _best effort_ attempt to execute the object, but if it fails the client does not wish to be notified
     * This eliminates a round trip in client-server interaction, and it is expected to be useful where failure is not critical or where the object executed might make its own callback to the client asynchronously
 * A request id (128-bit UUID) generated by the client and copied by the server into an `ExecutionResponse` message (in the case of `RETURN_RESPONSE` mode)
   * Each session in the session layer maintains a map of outstanding requests ids to objects on which client threads are blocked waiting for execution response messages, and the library will use this to unblock the relevant thread

===!ExecutionResponse Message===

`message_execution_response.proto`
{{{
package com.googlecode.mobilityrpc.protocol.protobuf;
import "component_serialization_format.proto";
import "component_request_identifier.proto";

message ExecutionResponse {
    enum ExecutionOutcome {
        VOID_RETURNED = 0;
        VALUE_RETURNED = 1;
        FAILURE = 2;
    }

    // An enum value which indicates whether the execution returned a response object or not, or whether execution failed
    required ExecutionOutcome execution_outcome = 1;

    // A serialized object whose type depends on the ExecutionOutcome:
    // if VOID_RETURNED - serialized_return_object will be zero bytes
    // if VALUE_RETURNED - serialized_return_object will be a serialized object returned by the Callable object
    // if FAILURE - a serialized RuntimeException wrapping whatever exception caused execution to fail
    required bytes serialized_return_object = 2;

    // The serialized format of the return object e.g. whether Kryo or Java serialization was used
    required SerializationFormat serialization_format = 3;

    // The request identifier, copied from the corresponding execution request originally sent by the client
    required RequestIdentifier request_identifier = 4;
}
}}}

The `ExecutionResponse` message is comprised of:
 * An `ExecutionOutcome` field, having one of three possible values:
   * `VOID_RETURNED` indicates that the entry point method when executed on the server had a void return type, or it returned null
   * `VALUE_RETURNED` indicates that the entry point method when executed on the server returned an object, and that the object will be found in the `serialized_return_object` field
   * `FAILURE` indicates that the entry point method when executed on the server threw an exception, and that the exception will be found in the `serialized_return_object` field
 * A field which indicates the serialization format of the serialized return object
 * A request identifier (128-bit UUID) generated by the client and copied by the server into this response message, which allows the client to unblock a waiting thread as discussed above

===Envelope Message===

`message_envelope.proto`
{{{
package com.googlecode.mobilityrpc.protocol.protobuf;

// Encapsulates protobuf data and indicates the type of message which has been
// serialized, so that the relevant protobuf class can be chosen to deserialize it
message Envelope {
    enum MessageType {
        EXECUTION_REQUEST = 1;
        EXECUTION_RESPONSE = 2;
        RESOURCE_REQUEST = 3;
        RESOURCE_RESPONSE = 4;
        PING = 5;
        PONG = 6;
    }

  required MessageType message_type = 1;
  required bytes message_bytes = 2;
}
}}}

Google Protocol Buffer messages serialize to a stream of bytes, and these bytes do not have a signature to allow the the serialized message's type be determined.

The type of the serialized message must be known before it can be deserialized. This is because it must be deserialized by the Protocol Buffer class generated from the relevant message's proto file.

This problem is solved by defining an `Envelope` message, which is comprised of:
 * A `message_bytes` field, containing another protobuf-serialized message
 * A `message_type` enum field, which indicates the type of the message that can be found in the `message_bytes` field

Thus every message that is sent is encapsulated in an `Envelope` message, and the receiving side therefore expects only to receive `Envelope` messages on the wire. The library on the receiving side will deserialize the envelope, then deserialize the contained message using the protobuf class appropriate for the message type.