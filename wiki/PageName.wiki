Mobility-RPC is a superset of [http://en.wikipedia.org/wiki/Remote_procedure_call RPC], a high-performance and easy-to-use library, which brings seamless [http://en.wikipedia.org/wiki/Code_mobility Code Mobility] to the Java platform.
Move objects or tasks between applications and machines, as easily as moving them around within a single application.

<wiki:toc max_depth="3" />

==Applications==
 * Radically different architectures in distributed applications
 * Replacement for conventional RPC
 * Grid computing
 * CPU scavenging
 * JVM sharing
 * Autonomous mobile agents

==What is Code Mobility?==
Code Mobility is the ability to transfer objects _and the classes on which they are based_, statefully, from one application or machine to another, at runtime.

The destination application does not need to contain the classes on which objects it receives are based. Mobile objects can similarly fetch objects from the remote application and return them back to the local application.

Code Mobility enables new classes of distributed application architectures. [WhatIsCodeMobility Read more]

==Features==
Mobility-RPC has been designed with the following goals.

*Focus on Plain Java Code*
  * No need to learn complex APIs, define remote interfaces, or implement java.io.Serializable
  * Seamless and type-safe compatibility with existing, regular, unmodified Java code and objects
  * Invoke arbitrary methods as well as third-party libraries cross-network seamlessly
*High performance*
  * Network protocol designed from the ground up with scalability, high concurrency, high throughput and low latency in mind
  * Outperforms RMI under a variety of traffic conditions, low-high concurrency, small-large request sizes
  * Synchronous and asynchronous invocation, callbacks and bi-directional invocation
  * _Fire and forget_ invocation to eliminate network round trip acknowledgements
  * Design patterns to short-circuit cross-network _conversations_
  * Low network overhead: compact data transfers, a single bi-directional multiplexed connection between machines
*Code Mobility*
  * RPC atop Code Mobility: supports design patterns which are not possible with conventional RPC
  * Supports all Code Mobility paradigms: remote evaluation, code on demand, mobile agents

==How does Mobility-RPC differ from conventional RPC?==

Conventional RPC is usually implemented using remote interfaces and proxy objects (or “stubs”).

Mobility-RPC takes a completely different approach. [ConventionalRpcComparison Read more]

==Example Usage==
These examples send objects to ficticious machines named [http://en.wikipedia.org/wiki/Alice_and_Bob alice and bob]. In practice replace these with the name or ip address of an actual machine to which you want to send an object.

----

===Hello World===
Print "Hello World" to the console on a remote machine called "bob".
{{{
public class HelloWorld {

    public static void main(String[] args) {
        QuickTask.execute("bob", new Runnable() { public void run() {
                System.out.println("Hello World");
        }});
    }
}
}}}

----

===Retrieve Data===
Retrieve system properties from the remote machine and print to the console on the local machine.
{{{
public class RetrieveData {

    public static void main(String[] args) {
        Properties data = QuickTask.execute("bob", new Callable<Properties>() {
            public Properties call() throws Exception {
                return System.getProperties();
            }
        });
        System.out.println(data);
    }
}
}}}

----

===Boomerang Pattern===
The Boomerang Pattern - a `Callable` object which returns itself.

Send a Callable object to a remote machine, where it gathers some data, and then returns itself back to the local machine. The data is printed to the console on the local machine.
{{{
public class BoomerangPattern {

    static class BoomerangObject implements Callable<BoomerangObject> {

        private Properties someData;
        private InetAddress someOtherData;

        public BoomerangObject call() throws Exception {
            someData = System.getProperties();
            someOtherData = InetAddress.getLocalHost();
            return this;
        }
    }

    public static void main(String[] args) {
        BoomerangObject boomerangObject = QuickTask.execute("bob", new BoomerangObject());
        System.out.println(boomerangObject.someData);
        System.out.println(boomerangObject.someOtherData);
    }
}
}}}

----

===Regular Object Migration===
Transfer a regular object to a remote machine. The object is not special in any way and does not implement any particular interfaces.

Send the object, and call its `printDetails()` method on the remote machine.
{{{
public class RegularObjectMigration {

    static class RegularObject {

        private String name = "Joe Bloggs";
        private String address = "Sesame Street";

        public void printDetails() {
            System.out.println(name);
            System.out.println(address);
        }
    }

    public static void main(String[] args) {
        final RegularObject regularObject = new RegularObject();
        QuickTask.execute("bob", new Runnable() { public void run() {
                regularObject.printDetails();
        }});
    }
}
}}}

----

===Mobile Agent===
An object which autonomously migrates itself around the network.

The main method transfers the object to machine _bob_, where the run() method is called. It prints "Hello World" and its hop number, 1, to the console on _bob_.

From _bob_ the object transfers itself to _alice_, which is the next machine on its list of machines to visit. It prints "Hello World" and its incremented hop number, 2, to the console on _alice_.

From _alice_ the object transfers itself back to _bob_ again, where it prints "Hello World" and an incremented hop number, 3, but then it finds that it has run out of machines to visit, so it prints "Ran out of machines to visit".

{{{
public class MobileAgentPattern {

    static class MobileAgent implements Runnable {
        private List<String> machinesToVisit = new ArrayList<String>(Arrays.asList("alice", "bob"));
        private int hopNumber = 0;

        public void run() {
            MobilitySession session = MobilityContext.getCurrentSession();
            System.out.println("Hello World, this is hop number: " + (++hopNumber) + " in " + session);
            if (machinesToVisit.isEmpty()) {
                System.out.println("Ran out of machines to visit");
            } else {
                // Migrate to next machine and remove from the list...
                session.execute(machinesToVisit.remove(0), this);
            }
            session.release();
        }
    }
    // Agent visits bob, then alice, then bob again...
    public static void main(String[] args) {
        QuickTask.execute("bob", new MobileAgent());
    }
}
}}}

*Output on bob*
{{{
Hello World, this is hop number: 1 in MobilitySession{sessionId=836d7e5f-42ca-445f-acf0-4db525dcd6ab}
Hello World, this is hop number: 3 in MobilitySession{sessionId=836d7e5f-42ca-445f-acf0-4db525dcd6ab}
Ran out of machines to visit
}}}
   
*Output on alice*
{{{
Hello World, this is hop number: 2 in MobilitySession{sessionId=836d7e5f-42ca-445f-acf0-4db525dcd6ab}
}}}

----

===Receive Incoming Objects===
You can run Mobility-RPC as a library inside your application on remote machine(s), or you can run Mobility-RPC as a standalone server in its own right on remote machine(s).

====Run as a library : receive incoming objects in your application====
Have your application call the following method to instruct the Mobility-RPC library to listen for incoming objects. Objects from client machines could then interact with your application on that machine.
{{{
EmbeddedMobilityServer.start();
}}}
Note if your application will both send and receive objects, it is recommended that you use the same `MobilityController` for both, as provided by [http://mobility-rpc.googlecode.com/svn/mobility-rpc/javadoc/apidocs/com/googlecode/mobilityrpc/quickstart/EmbeddedMobilityServer.html EmbeddedMobilityServer].

====Run as a standalone server: send objects to arbitrary machines====
The Mobility-RPC library alternatively can be run as a standalone server to receive and execute incoming objects.

Download the Mobility-RPC jar from the [http://code.google.com/p/mobility-rpc/downloads/list Downloads] tab, and then there are two ways to launch it as follows.

_*Method 1: Run in Graphical Mode*_

 * Double-click the jar on the machine on which you want to run the server. This will start Mobility-RPC as a standalone server, and it will add an icon to the system tray on Windows, the menu bar on Mac, or the notification area on Linux automatically.

 * The icon displays the IP address on which the server is running, which you can use that to send objects to the machine. The icon also allows you to shut down the mobility-rpc server when you have finished.

_*Method 2: Run from the command line*_

 * The standalone server can be launched from the command line as follows: `java -jar mobility-rpc-1.0.0-all.jar`

 * If a GUI is available, this will also start mobility-rpc standalone server in the system tray. If you wish to force the library not to use the GUI, supply "`-Dcom.googlecode.mobilityrpc.headless=true`" as a command line parameter. If no GUI is available in the first place (for example on a headless Linux server), the library will run "headless" automatically.

*Firewalls*

Note: if you have a firewall on the remote machine, choose to allow incoming connections to *port 5739* on that machine.

----

===Testing the Examples===
Once you have launched Mobility-RPC as a server on a remote machine, take note of the IP address on which it is listening.

To run the example code provided above, add mobility-rpc as a dependency to your project in your IDE on your local machine. Then copy and paste the examples into your IDE. Replace "alice" or "bob" in the example code with the ip address on which the server is running. You can then start sending objects to the remote machine. You can launch the server on multiple remote machines, and build very sophisticated applications. 

See [http://mobility-rpc.googlecode.com/svn/mobility-rpc/javadoc/apidocs/com/googlecode/mobilityrpc/quickstart/StandaloneMobilityServer.html StandaloneMobilityServer] for more details.

----

==API==
The examples above mostly use the [http://mobility-rpc.googlecode.com/svn/mobility-rpc/javadoc/apidocs/com/googlecode/mobilityrpc/quickstart/package-summary.html QuickTask] class, in the [http://mobility-rpc.googlecode.com/svn/mobility-rpc/javadoc/apidocs/com/googlecode/mobilityrpc/quickstart/package-summary.html quickstart] package - a simplified API to the library, wrapping the main APIs, tailored for specific use cases and for getting started with the library quickly.

The main APIs of the library are marked `[`public api`]` in the [http://mobility-rpc.googlecode.com/svn/mobility-rpc/javadoc/apidocs/index.html API JavaDocs], but essentially the main API is as follows:

 * [http://mobility-rpc.googlecode.com/svn/mobility-rpc/javadoc/apidocs/com/googlecode/mobilityrpc/MobilityRPC.html MobilityRPC] - A static factory, to get an instance of `MobilityController`
 * [http://mobility-rpc.googlecode.com/svn/mobility-rpc/javadoc/apidocs/com/googlecode/mobilityrpc/controller/MobilityController.html MobilityController] - Manages an instance of the library
 * [http://mobility-rpc.googlecode.com/svn/mobility-rpc/javadoc/apidocs/com/googlecode/mobilityrpc/session/MobilitySession.html MobilitySession] - The gateway through which the application can send objects to remote machines

==Usage in Maven projects==
The library is in [http://search.maven.org/ Maven Central], and so can be added and used in a [http://maven.apache.org/ Maven] project as follows.
{{{
<dependency>
    <groupId>com.googlecode.mobilityrpc</groupId>
    <artifactId>mobility-rpc</artifactId>
    <version>1.0.0</version>
</dependency>
}}}

==Usage in non-Maven projects==
The library has some dependencies of it's own (see TechnologiesUsed), which, above, Maven would take care of automatically.

For non-Mavenized projects, a special build of the library is also provided, which contains the library and all of the library's own dependencies embedded within a single jar file (ending "-all"). This build is available in the [http://code.google.com/p/mobility-rpc/downloads/list Downloads] tab. This is the same build that can be run as a standalone server as discussed above.

This build, known as a _shaded_ jar, is built using the [http://maven.apache.org/plugins/maven-shade-plugin/ maven-shade-plugin]. This allows the library's own dependencies to be copied into the library's jar while at the same time relocating classes from the library's dependency jars into different packages within the jar. This means that the shaded jar is safe to use as a dependency in a non-mavenized project - it will not conflict with other jars or packages on the class path.

==Compiling from source==
If you want to compile from source (see the Source tab) and tinker with the internals of the library itself, you will need [http://code.google.com/p/protobuf/ Protobuf] on your machine. That's command {{{sudo port install protobuf-java}}} if you're on Mac, {{{sudo apt-get install protobuf-java}}} (or similar) if you're on Linux, or download the binaries manually from the Protobuf website if you're on Windows.

==Documentation==
For more documentation, see the [http://code.google.com/p/mobility-rpc/w/list Wiki] tab.

==News==
Mobility-RPC is now in Maven Central. The latest release is 1.0.0 as of November 2012 - see ReleaseNotes.

The best way to get started is to add the library as a dependency to a Maven project, and try running a few of the examples above in your IDE, to send objects to another application instance, or to a machine with the jar running as a server.

Report any issues in the Issues tab, and feel free to ask questions in the [http://groups.google.com/group/mobility-rpc-discuss Discussion Group].